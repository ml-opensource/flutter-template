// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'response_errors.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ResponseErrorsTearOff {
  const _$ResponseErrorsTearOff();

  _NoInternetConnection<T> noInternetConnection<T>() {
    return _NoInternetConnection<T>();
  }

  _SendTimeout<T> sendTimeout<T>() {
    return _SendTimeout<T>();
  }

  _ConnectTimeout<T> connectTimeout<T>() {
    return _ConnectTimeout<T>();
  }

  _ReceiveTimeout<T> receiveTimeout<T>() {
    return _ReceiveTimeout<T>();
  }

  _BadRequest<T> badRequest<T>() {
    return _BadRequest<T>();
  }

  _NotFound<T> notFound<T>() {
    return _NotFound<T>();
  }

  _TooManyRequests<T> tooManyRequests<T>() {
    return _TooManyRequests<T>();
  }

  _UnprocessableEntity<T> unprocessableEntity<T>() {
    return _UnprocessableEntity<T>();
  }

  _InternalServerError<T> internalServerError<T>() {
    return _InternalServerError<T>();
  }

  _UnexpectedError<T> unexpectedError<T>() {
    return _UnexpectedError<T>();
  }

  _RequestCancelled<T> requestCancelled<T>() {
    return _RequestCancelled<T>();
  }

  _Conflict<T> conflict<T>() {
    return _Conflict<T>();
  }

  _Unauthorized<T> unauthorized<T>() {
    return _Unauthorized<T>();
  }

  InvalidPasswordError<T> invalidPassword<T>() {
    return InvalidPasswordError<T>();
  }

  InvalidEmailError<T> invalidEmail<T>() {
    return InvalidEmailError<T>();
  }

  _InvalidLoginCredentials<T> invalidLoginCredentials<T>() {
    return _InvalidLoginCredentials<T>();
  }

  InvalidSearchTermError<T> invalidSearhTerm<T>() {
    return InvalidSearchTermError<T>();
  }
}

/// @nodoc
const $ResponseErrors = _$ResponseErrorsTearOff();

/// @nodoc
mixin _$ResponseErrors<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseErrorsCopyWith<T, $Res> {
  factory $ResponseErrorsCopyWith(
          ResponseErrors<T> value, $Res Function(ResponseErrors<T>) then) =
      _$ResponseErrorsCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ResponseErrorsCopyWithImpl<T, $Res>
    implements $ResponseErrorsCopyWith<T, $Res> {
  _$ResponseErrorsCopyWithImpl(this._value, this._then);

  final ResponseErrors<T> _value;
  // ignore: unused_field
  final $Res Function(ResponseErrors<T>) _then;
}

/// @nodoc
abstract class _$NoInternetConnectionCopyWith<T, $Res> {
  factory _$NoInternetConnectionCopyWith(_NoInternetConnection<T> value,
          $Res Function(_NoInternetConnection<T>) then) =
      __$NoInternetConnectionCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$NoInternetConnectionCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$NoInternetConnectionCopyWith<T, $Res> {
  __$NoInternetConnectionCopyWithImpl(_NoInternetConnection<T> _value,
      $Res Function(_NoInternetConnection<T>) _then)
      : super(_value, (v) => _then(v as _NoInternetConnection<T>));

  @override
  _NoInternetConnection<T> get _value =>
      super._value as _NoInternetConnection<T>;
}

/// @nodoc

class _$_NoInternetConnection<T> extends _NoInternetConnection<T>
    with DiagnosticableTreeMixin {
  const _$_NoInternetConnection() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.noInternetConnection()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ResponseErrors<$T>.noInternetConnection'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NoInternetConnection<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return noInternetConnection();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (noInternetConnection != null) {
      return noInternetConnection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return noInternetConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (noInternetConnection != null) {
      return noInternetConnection(this);
    }
    return orElse();
  }
}

abstract class _NoInternetConnection<T> extends ResponseErrors<T> {
  const factory _NoInternetConnection() = _$_NoInternetConnection<T>;
  const _NoInternetConnection._() : super._();
}

/// @nodoc
abstract class _$SendTimeoutCopyWith<T, $Res> {
  factory _$SendTimeoutCopyWith(
          _SendTimeout<T> value, $Res Function(_SendTimeout<T>) then) =
      __$SendTimeoutCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$SendTimeoutCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$SendTimeoutCopyWith<T, $Res> {
  __$SendTimeoutCopyWithImpl(
      _SendTimeout<T> _value, $Res Function(_SendTimeout<T>) _then)
      : super(_value, (v) => _then(v as _SendTimeout<T>));

  @override
  _SendTimeout<T> get _value => super._value as _SendTimeout<T>;
}

/// @nodoc

class _$_SendTimeout<T> extends _SendTimeout<T> with DiagnosticableTreeMixin {
  const _$_SendTimeout() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.sendTimeout()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.sendTimeout'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SendTimeout<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class _SendTimeout<T> extends ResponseErrors<T> {
  const factory _SendTimeout() = _$_SendTimeout<T>;
  const _SendTimeout._() : super._();
}

/// @nodoc
abstract class _$ConnectTimeoutCopyWith<T, $Res> {
  factory _$ConnectTimeoutCopyWith(
          _ConnectTimeout<T> value, $Res Function(_ConnectTimeout<T>) then) =
      __$ConnectTimeoutCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$ConnectTimeoutCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$ConnectTimeoutCopyWith<T, $Res> {
  __$ConnectTimeoutCopyWithImpl(
      _ConnectTimeout<T> _value, $Res Function(_ConnectTimeout<T>) _then)
      : super(_value, (v) => _then(v as _ConnectTimeout<T>));

  @override
  _ConnectTimeout<T> get _value => super._value as _ConnectTimeout<T>;
}

/// @nodoc

class _$_ConnectTimeout<T> extends _ConnectTimeout<T>
    with DiagnosticableTreeMixin {
  const _$_ConnectTimeout() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.connectTimeout()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.connectTimeout'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ConnectTimeout<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return connectTimeout();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (connectTimeout != null) {
      return connectTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return connectTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (connectTimeout != null) {
      return connectTimeout(this);
    }
    return orElse();
  }
}

abstract class _ConnectTimeout<T> extends ResponseErrors<T> {
  const factory _ConnectTimeout() = _$_ConnectTimeout<T>;
  const _ConnectTimeout._() : super._();
}

/// @nodoc
abstract class _$ReceiveTimeoutCopyWith<T, $Res> {
  factory _$ReceiveTimeoutCopyWith(
          _ReceiveTimeout<T> value, $Res Function(_ReceiveTimeout<T>) then) =
      __$ReceiveTimeoutCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$ReceiveTimeoutCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$ReceiveTimeoutCopyWith<T, $Res> {
  __$ReceiveTimeoutCopyWithImpl(
      _ReceiveTimeout<T> _value, $Res Function(_ReceiveTimeout<T>) _then)
      : super(_value, (v) => _then(v as _ReceiveTimeout<T>));

  @override
  _ReceiveTimeout<T> get _value => super._value as _ReceiveTimeout<T>;
}

/// @nodoc

class _$_ReceiveTimeout<T> extends _ReceiveTimeout<T>
    with DiagnosticableTreeMixin {
  const _$_ReceiveTimeout() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.receiveTimeout()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.receiveTimeout'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ReceiveTimeout<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class _ReceiveTimeout<T> extends ResponseErrors<T> {
  const factory _ReceiveTimeout() = _$_ReceiveTimeout<T>;
  const _ReceiveTimeout._() : super._();
}

/// @nodoc
abstract class _$BadRequestCopyWith<T, $Res> {
  factory _$BadRequestCopyWith(
          _BadRequest<T> value, $Res Function(_BadRequest<T>) then) =
      __$BadRequestCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$BadRequestCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$BadRequestCopyWith<T, $Res> {
  __$BadRequestCopyWithImpl(
      _BadRequest<T> _value, $Res Function(_BadRequest<T>) _then)
      : super(_value, (v) => _then(v as _BadRequest<T>));

  @override
  _BadRequest<T> get _value => super._value as _BadRequest<T>;
}

/// @nodoc

class _$_BadRequest<T> extends _BadRequest<T> with DiagnosticableTreeMixin {
  const _$_BadRequest() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.badRequest()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.badRequest'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BadRequest<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return badRequest();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (badRequest != null) {
      return badRequest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return badRequest(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (badRequest != null) {
      return badRequest(this);
    }
    return orElse();
  }
}

abstract class _BadRequest<T> extends ResponseErrors<T> {
  const factory _BadRequest() = _$_BadRequest<T>;
  const _BadRequest._() : super._();
}

/// @nodoc
abstract class _$NotFoundCopyWith<T, $Res> {
  factory _$NotFoundCopyWith(
          _NotFound<T> value, $Res Function(_NotFound<T>) then) =
      __$NotFoundCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$NotFoundCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$NotFoundCopyWith<T, $Res> {
  __$NotFoundCopyWithImpl(
      _NotFound<T> _value, $Res Function(_NotFound<T>) _then)
      : super(_value, (v) => _then(v as _NotFound<T>));

  @override
  _NotFound<T> get _value => super._value as _NotFound<T>;
}

/// @nodoc

class _$_NotFound<T> extends _NotFound<T> with DiagnosticableTreeMixin {
  const _$_NotFound() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.notFound()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.notFound'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NotFound<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _NotFound<T> extends ResponseErrors<T> {
  const factory _NotFound() = _$_NotFound<T>;
  const _NotFound._() : super._();
}

/// @nodoc
abstract class _$TooManyRequestsCopyWith<T, $Res> {
  factory _$TooManyRequestsCopyWith(
          _TooManyRequests<T> value, $Res Function(_TooManyRequests<T>) then) =
      __$TooManyRequestsCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$TooManyRequestsCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$TooManyRequestsCopyWith<T, $Res> {
  __$TooManyRequestsCopyWithImpl(
      _TooManyRequests<T> _value, $Res Function(_TooManyRequests<T>) _then)
      : super(_value, (v) => _then(v as _TooManyRequests<T>));

  @override
  _TooManyRequests<T> get _value => super._value as _TooManyRequests<T>;
}

/// @nodoc

class _$_TooManyRequests<T> extends _TooManyRequests<T>
    with DiagnosticableTreeMixin {
  const _$_TooManyRequests() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.tooManyRequests()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.tooManyRequests'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _TooManyRequests<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return tooManyRequests();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (tooManyRequests != null) {
      return tooManyRequests();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return tooManyRequests(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (tooManyRequests != null) {
      return tooManyRequests(this);
    }
    return orElse();
  }
}

abstract class _TooManyRequests<T> extends ResponseErrors<T> {
  const factory _TooManyRequests() = _$_TooManyRequests<T>;
  const _TooManyRequests._() : super._();
}

/// @nodoc
abstract class _$UnprocessableEntityCopyWith<T, $Res> {
  factory _$UnprocessableEntityCopyWith(_UnprocessableEntity<T> value,
          $Res Function(_UnprocessableEntity<T>) then) =
      __$UnprocessableEntityCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$UnprocessableEntityCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$UnprocessableEntityCopyWith<T, $Res> {
  __$UnprocessableEntityCopyWithImpl(_UnprocessableEntity<T> _value,
      $Res Function(_UnprocessableEntity<T>) _then)
      : super(_value, (v) => _then(v as _UnprocessableEntity<T>));

  @override
  _UnprocessableEntity<T> get _value => super._value as _UnprocessableEntity<T>;
}

/// @nodoc

class _$_UnprocessableEntity<T> extends _UnprocessableEntity<T>
    with DiagnosticableTreeMixin {
  const _$_UnprocessableEntity() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.unprocessableEntity()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ResponseErrors<$T>.unprocessableEntity'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _UnprocessableEntity<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return unprocessableEntity();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (unprocessableEntity != null) {
      return unprocessableEntity();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return unprocessableEntity(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (unprocessableEntity != null) {
      return unprocessableEntity(this);
    }
    return orElse();
  }
}

abstract class _UnprocessableEntity<T> extends ResponseErrors<T> {
  const factory _UnprocessableEntity() = _$_UnprocessableEntity<T>;
  const _UnprocessableEntity._() : super._();
}

/// @nodoc
abstract class _$InternalServerErrorCopyWith<T, $Res> {
  factory _$InternalServerErrorCopyWith(_InternalServerError<T> value,
          $Res Function(_InternalServerError<T>) then) =
      __$InternalServerErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$InternalServerErrorCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$InternalServerErrorCopyWith<T, $Res> {
  __$InternalServerErrorCopyWithImpl(_InternalServerError<T> _value,
      $Res Function(_InternalServerError<T>) _then)
      : super(_value, (v) => _then(v as _InternalServerError<T>));

  @override
  _InternalServerError<T> get _value => super._value as _InternalServerError<T>;
}

/// @nodoc

class _$_InternalServerError<T> extends _InternalServerError<T>
    with DiagnosticableTreeMixin {
  const _$_InternalServerError() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.internalServerError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ResponseErrors<$T>.internalServerError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InternalServerError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return internalServerError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (internalServerError != null) {
      return internalServerError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return internalServerError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (internalServerError != null) {
      return internalServerError(this);
    }
    return orElse();
  }
}

abstract class _InternalServerError<T> extends ResponseErrors<T> {
  const factory _InternalServerError() = _$_InternalServerError<T>;
  const _InternalServerError._() : super._();
}

/// @nodoc
abstract class _$UnexpectedErrorCopyWith<T, $Res> {
  factory _$UnexpectedErrorCopyWith(
          _UnexpectedError<T> value, $Res Function(_UnexpectedError<T>) then) =
      __$UnexpectedErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$UnexpectedErrorCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$UnexpectedErrorCopyWith<T, $Res> {
  __$UnexpectedErrorCopyWithImpl(
      _UnexpectedError<T> _value, $Res Function(_UnexpectedError<T>) _then)
      : super(_value, (v) => _then(v as _UnexpectedError<T>));

  @override
  _UnexpectedError<T> get _value => super._value as _UnexpectedError<T>;
}

/// @nodoc

class _$_UnexpectedError<T> extends _UnexpectedError<T>
    with DiagnosticableTreeMixin {
  const _$_UnexpectedError() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.unexpectedError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.unexpectedError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _UnexpectedError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return unexpectedError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return unexpectedError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(this);
    }
    return orElse();
  }
}

abstract class _UnexpectedError<T> extends ResponseErrors<T> {
  const factory _UnexpectedError() = _$_UnexpectedError<T>;
  const _UnexpectedError._() : super._();
}

/// @nodoc
abstract class _$RequestCancelledCopyWith<T, $Res> {
  factory _$RequestCancelledCopyWith(_RequestCancelled<T> value,
          $Res Function(_RequestCancelled<T>) then) =
      __$RequestCancelledCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$RequestCancelledCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$RequestCancelledCopyWith<T, $Res> {
  __$RequestCancelledCopyWithImpl(
      _RequestCancelled<T> _value, $Res Function(_RequestCancelled<T>) _then)
      : super(_value, (v) => _then(v as _RequestCancelled<T>));

  @override
  _RequestCancelled<T> get _value => super._value as _RequestCancelled<T>;
}

/// @nodoc

class _$_RequestCancelled<T> extends _RequestCancelled<T>
    with DiagnosticableTreeMixin {
  const _$_RequestCancelled() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.requestCancelled()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.requestCancelled'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RequestCancelled<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return requestCancelled();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (requestCancelled != null) {
      return requestCancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return requestCancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (requestCancelled != null) {
      return requestCancelled(this);
    }
    return orElse();
  }
}

abstract class _RequestCancelled<T> extends ResponseErrors<T> {
  const factory _RequestCancelled() = _$_RequestCancelled<T>;
  const _RequestCancelled._() : super._();
}

/// @nodoc
abstract class _$ConflictCopyWith<T, $Res> {
  factory _$ConflictCopyWith(
          _Conflict<T> value, $Res Function(_Conflict<T>) then) =
      __$ConflictCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$ConflictCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$ConflictCopyWith<T, $Res> {
  __$ConflictCopyWithImpl(
      _Conflict<T> _value, $Res Function(_Conflict<T>) _then)
      : super(_value, (v) => _then(v as _Conflict<T>));

  @override
  _Conflict<T> get _value => super._value as _Conflict<T>;
}

/// @nodoc

class _$_Conflict<T> extends _Conflict<T> with DiagnosticableTreeMixin {
  const _$_Conflict() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.conflict()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.conflict'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Conflict<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return conflict();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (conflict != null) {
      return conflict();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return conflict(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (conflict != null) {
      return conflict(this);
    }
    return orElse();
  }
}

abstract class _Conflict<T> extends ResponseErrors<T> {
  const factory _Conflict() = _$_Conflict<T>;
  const _Conflict._() : super._();
}

/// @nodoc
abstract class _$UnauthorizedCopyWith<T, $Res> {
  factory _$UnauthorizedCopyWith(
          _Unauthorized<T> value, $Res Function(_Unauthorized<T>) then) =
      __$UnauthorizedCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$UnauthorizedCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$UnauthorizedCopyWith<T, $Res> {
  __$UnauthorizedCopyWithImpl(
      _Unauthorized<T> _value, $Res Function(_Unauthorized<T>) _then)
      : super(_value, (v) => _then(v as _Unauthorized<T>));

  @override
  _Unauthorized<T> get _value => super._value as _Unauthorized<T>;
}

/// @nodoc

class _$_Unauthorized<T> extends _Unauthorized<T> with DiagnosticableTreeMixin {
  const _$_Unauthorized() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.unauthorized()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.unauthorized'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Unauthorized<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return unauthorized();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return unauthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(this);
    }
    return orElse();
  }
}

abstract class _Unauthorized<T> extends ResponseErrors<T> {
  const factory _Unauthorized() = _$_Unauthorized<T>;
  const _Unauthorized._() : super._();
}

/// @nodoc
abstract class $InvalidPasswordErrorCopyWith<T, $Res> {
  factory $InvalidPasswordErrorCopyWith(InvalidPasswordError<T> value,
          $Res Function(InvalidPasswordError<T>) then) =
      _$InvalidPasswordErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$InvalidPasswordErrorCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements $InvalidPasswordErrorCopyWith<T, $Res> {
  _$InvalidPasswordErrorCopyWithImpl(InvalidPasswordError<T> _value,
      $Res Function(InvalidPasswordError<T>) _then)
      : super(_value, (v) => _then(v as InvalidPasswordError<T>));

  @override
  InvalidPasswordError<T> get _value => super._value as InvalidPasswordError<T>;
}

/// @nodoc

class _$InvalidPasswordError<T> extends InvalidPasswordError<T>
    with DiagnosticableTreeMixin {
  const _$InvalidPasswordError() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.invalidPassword()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.invalidPassword'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidPasswordError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return invalidPassword();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidPassword != null) {
      return invalidPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return invalidPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidPassword != null) {
      return invalidPassword(this);
    }
    return orElse();
  }
}

abstract class InvalidPasswordError<T> extends ResponseErrors<T> {
  const factory InvalidPasswordError() = _$InvalidPasswordError<T>;
  const InvalidPasswordError._() : super._();
}

/// @nodoc
abstract class $InvalidEmailErrorCopyWith<T, $Res> {
  factory $InvalidEmailErrorCopyWith(InvalidEmailError<T> value,
          $Res Function(InvalidEmailError<T>) then) =
      _$InvalidEmailErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$InvalidEmailErrorCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements $InvalidEmailErrorCopyWith<T, $Res> {
  _$InvalidEmailErrorCopyWithImpl(
      InvalidEmailError<T> _value, $Res Function(InvalidEmailError<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmailError<T>));

  @override
  InvalidEmailError<T> get _value => super._value as InvalidEmailError<T>;
}

/// @nodoc

class _$InvalidEmailError<T> extends InvalidEmailError<T>
    with DiagnosticableTreeMixin {
  const _$InvalidEmailError() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.invalidEmail()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.invalidEmail'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmailError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return invalidEmail();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailError<T> extends ResponseErrors<T> {
  const factory InvalidEmailError() = _$InvalidEmailError<T>;
  const InvalidEmailError._() : super._();
}

/// @nodoc
abstract class _$InvalidLoginCredentialsCopyWith<T, $Res> {
  factory _$InvalidLoginCredentialsCopyWith(_InvalidLoginCredentials<T> value,
          $Res Function(_InvalidLoginCredentials<T>) then) =
      __$InvalidLoginCredentialsCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$InvalidLoginCredentialsCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements _$InvalidLoginCredentialsCopyWith<T, $Res> {
  __$InvalidLoginCredentialsCopyWithImpl(_InvalidLoginCredentials<T> _value,
      $Res Function(_InvalidLoginCredentials<T>) _then)
      : super(_value, (v) => _then(v as _InvalidLoginCredentials<T>));

  @override
  _InvalidLoginCredentials<T> get _value =>
      super._value as _InvalidLoginCredentials<T>;
}

/// @nodoc

class _$_InvalidLoginCredentials<T> extends _InvalidLoginCredentials<T>
    with DiagnosticableTreeMixin {
  const _$_InvalidLoginCredentials() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.invalidLoginCredentials()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ResponseErrors<$T>.invalidLoginCredentials'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InvalidLoginCredentials<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return invalidLoginCredentials();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidLoginCredentials != null) {
      return invalidLoginCredentials();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return invalidLoginCredentials(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidLoginCredentials != null) {
      return invalidLoginCredentials(this);
    }
    return orElse();
  }
}

abstract class _InvalidLoginCredentials<T> extends ResponseErrors<T> {
  const factory _InvalidLoginCredentials() = _$_InvalidLoginCredentials<T>;
  const _InvalidLoginCredentials._() : super._();
}

/// @nodoc
abstract class $InvalidSearchTermErrorCopyWith<T, $Res> {
  factory $InvalidSearchTermErrorCopyWith(InvalidSearchTermError<T> value,
          $Res Function(InvalidSearchTermError<T>) then) =
      _$InvalidSearchTermErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$InvalidSearchTermErrorCopyWithImpl<T, $Res>
    extends _$ResponseErrorsCopyWithImpl<T, $Res>
    implements $InvalidSearchTermErrorCopyWith<T, $Res> {
  _$InvalidSearchTermErrorCopyWithImpl(InvalidSearchTermError<T> _value,
      $Res Function(InvalidSearchTermError<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchTermError<T>));

  @override
  InvalidSearchTermError<T> get _value =>
      super._value as InvalidSearchTermError<T>;
}

/// @nodoc

class _$InvalidSearchTermError<T> extends InvalidSearchTermError<T>
    with DiagnosticableTreeMixin {
  const _$InvalidSearchTermError() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResponseErrors<$T>.invalidSearhTerm()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResponseErrors<$T>.invalidSearhTerm'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidSearchTermError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noInternetConnection,
    required TResult Function() sendTimeout,
    required TResult Function() connectTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badRequest,
    required TResult Function() notFound,
    required TResult Function() tooManyRequests,
    required TResult Function() unprocessableEntity,
    required TResult Function() internalServerError,
    required TResult Function() unexpectedError,
    required TResult Function() requestCancelled,
    required TResult Function() conflict,
    required TResult Function() unauthorized,
    required TResult Function() invalidPassword,
    required TResult Function() invalidEmail,
    required TResult Function() invalidLoginCredentials,
    required TResult Function() invalidSearhTerm,
  }) {
    return invalidSearhTerm();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noInternetConnection,
    TResult Function()? sendTimeout,
    TResult Function()? connectTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badRequest,
    TResult Function()? notFound,
    TResult Function()? tooManyRequests,
    TResult Function()? unprocessableEntity,
    TResult Function()? internalServerError,
    TResult Function()? unexpectedError,
    TResult Function()? requestCancelled,
    TResult Function()? conflict,
    TResult Function()? unauthorized,
    TResult Function()? invalidPassword,
    TResult Function()? invalidEmail,
    TResult Function()? invalidLoginCredentials,
    TResult Function()? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidSearhTerm != null) {
      return invalidSearhTerm();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoInternetConnection<T> value)
        noInternetConnection,
    required TResult Function(_SendTimeout<T> value) sendTimeout,
    required TResult Function(_ConnectTimeout<T> value) connectTimeout,
    required TResult Function(_ReceiveTimeout<T> value) receiveTimeout,
    required TResult Function(_BadRequest<T> value) badRequest,
    required TResult Function(_NotFound<T> value) notFound,
    required TResult Function(_TooManyRequests<T> value) tooManyRequests,
    required TResult Function(_UnprocessableEntity<T> value)
        unprocessableEntity,
    required TResult Function(_InternalServerError<T> value)
        internalServerError,
    required TResult Function(_UnexpectedError<T> value) unexpectedError,
    required TResult Function(_RequestCancelled<T> value) requestCancelled,
    required TResult Function(_Conflict<T> value) conflict,
    required TResult Function(_Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidPasswordError<T> value) invalidPassword,
    required TResult Function(InvalidEmailError<T> value) invalidEmail,
    required TResult Function(_InvalidLoginCredentials<T> value)
        invalidLoginCredentials,
    required TResult Function(InvalidSearchTermError<T> value) invalidSearhTerm,
  }) {
    return invalidSearhTerm(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoInternetConnection<T> value)? noInternetConnection,
    TResult Function(_SendTimeout<T> value)? sendTimeout,
    TResult Function(_ConnectTimeout<T> value)? connectTimeout,
    TResult Function(_ReceiveTimeout<T> value)? receiveTimeout,
    TResult Function(_BadRequest<T> value)? badRequest,
    TResult Function(_NotFound<T> value)? notFound,
    TResult Function(_TooManyRequests<T> value)? tooManyRequests,
    TResult Function(_UnprocessableEntity<T> value)? unprocessableEntity,
    TResult Function(_InternalServerError<T> value)? internalServerError,
    TResult Function(_UnexpectedError<T> value)? unexpectedError,
    TResult Function(_RequestCancelled<T> value)? requestCancelled,
    TResult Function(_Conflict<T> value)? conflict,
    TResult Function(_Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidPasswordError<T> value)? invalidPassword,
    TResult Function(InvalidEmailError<T> value)? invalidEmail,
    TResult Function(_InvalidLoginCredentials<T> value)?
        invalidLoginCredentials,
    TResult Function(InvalidSearchTermError<T> value)? invalidSearhTerm,
    required TResult orElse(),
  }) {
    if (invalidSearhTerm != null) {
      return invalidSearhTerm(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchTermError<T> extends ResponseErrors<T> {
  const factory InvalidSearchTermError() = _$InvalidSearchTermError<T>;
  const InvalidSearchTermError._() : super._();
}
